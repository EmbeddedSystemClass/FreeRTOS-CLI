/**
  ********************************************************************************
  * @File Name    : cli_register.c
  * @Author       : Jungle
  * @Mail         : Mail
  * @Created Time : 2018年3月20日 10:21:43
  * @Version      : V1.0
  * @Last Changed : 2018年3月27日 13:13:26
  * @Brief        : brief
  ********************************************************************************
  */

/* Inlcude ---------------------------------------------------------------------*/
#include "task.h"

#include "stdio.h"
#include "stdlib.h"
#include "string.h"

#include <common.h>
#include <cli_register.h>

/** @addtogroup Cli_Project
  * @{
  */

/* Private typedef -------------------------------------------------------------*/
typedef void (* pfCOMMAND_LINE_CALLBACK)(void);
typedef struct sCOMMAND_LINE_INPUT
{
	const char * const pcCommandString;/* The command that causes pfCommandInterpreter to be executed. For example "help".  Must be all lower case. */
	const char * const pcHelpString;   /* String that describes how to use the command. Should start with the command itself, and end with "\r\n".
	                                      For example "help: Display command line tool usage instructions\r\n". */
    const struct sCOMMAND_LINE_INPUT * psCommandSubMenu;/* If this command is a Submenu */
	const pfCOMMAND_LINE_CALLBACK pfCommandInterpreter;	/* A pointer to the callback function that will return the output generated by the command. */
}CLI_Command_Definition_t;

/* Private constants define ----------------------------------------------------*/
/* Private macro define --------------------------------------------------------*/
#define CLI_Command_Definition_t_End        {NULL, NULL, (const CLI_Command_Definition_t *)NULL, (pfCOMMAND_LINE_CALLBACK)NULL}
#define CLI_isDebugOn                       xCliDebugStatus.cliDebugStatusBit.CLI

/* Private function declaration ------------------------------------------------*/
static void help(void);
static void listShowAllCommond(void);
static void infoSysVersion(void);

/* Private variables -----------------------------------------------------------*/
static char * pcCommondParamExtract = NULL;
static const CLI_Command_Definition_t xSysCommandSubMenu[];
static const CLI_Command_Definition_t xTestCommandSubMenu[];

/* The definition of the "help" command.  This command is always at the front of the list of registered commands. */
/* The definition of the list of commands.  Commands that are registered are added to this list. */
static const CLI_Command_Definition_t xRegisteredCommands[] =
{
	{"info", "\r\n\tinfo: Display system version information.",   (const CLI_Command_Definition_t *)NULL, (pfCOMMAND_LINE_CALLBACK)infoSysVersion},
	{"SYS",  "\r\n\tSYS : Enter the system debug submenu.",       xSysCommandSubMenu,                     (pfCOMMAND_LINE_CALLBACK)NULL},
	{"TEST", "\r\n\tTEST: Enter the system test submenu.",        xTestCommandSubMenu,                    (pfCOMMAND_LINE_CALLBACK)NULL},
	CLI_Command_Definition_t_End
};
static const CLI_Command_Definition_t *psCommand = xRegisteredCommands;

/* Firmware version definition */
static const unsigned char VersionMajor = 03;
static const unsigned char VersionMinor = 04;

extern const char * pcMenuNameString;

/* Private functions -----------------------------------------------------------*/
/**
  * @brief  :
  * @param  : None
  * @retval : None
  */
void cli_interpret_command(const char * const pcCommandInput, char * pcWriteBuffer, unsigned char xWriteBufferLen)
{
    static const char * const CLI_Commond_Return_Main_Menu = "cd /";//4
    static const char * const CLI_Commond_List_All_Commond = "ls .";//4
    static const char * const CLI_Commond_Help_Info = "help";//4

    const CLI_Command_Definition_t *psCommandTemp = psCommand;

    const char *pcRegisteredCommandString;
    unsigned char xCommandStringLength;

    if(strncmp(pcCommandInput, CLI_Commond_Return_Main_Menu, 4) == 0) {
        psCommand = xRegisteredCommands;//root
        pcMenuNameString = pcCmdLineString;
        return;
    }

    if(strncmp(pcCommandInput, CLI_Commond_List_All_Commond, 4) == 0) {
        listShowAllCommond();
        return;
    }

    if(strncmp(pcCommandInput, CLI_Commond_Help_Info, 4) == 0) {
        help();
        return;
    }

    /* Search for the command string in the list of registered commands. */
	for(; psCommandTemp->pcCommandString != NULL; psCommandTemp++) {

		pcRegisteredCommandString = psCommandTemp->pcCommandString;
		xCommandStringLength = strlen(pcRegisteredCommandString);

		/* To ensure the string lengths match exactly, so as not to pick up a sub-string of a longer command,
		check the byte after the expected end of the string is either the end of the string or a space before a parameter. */
		if((pcCommandInput[xCommandStringLength] == ' ') || (pcCommandInput[xCommandStringLength] == 0x00)) {

			if(strncmp(pcCommandInput, pcRegisteredCommandString, xCommandStringLength) == 0) {//strncmp: Match Case

				/* The command has been found.  Check it has the expected number of parameters.
				If cExpectedNumberOfParameters is -1, then there could be a variable number of parameters and no check is made. */
				if(psCommandTemp->psCommandSubMenu != NULL) {
                    pcMenuNameString = psCommandTemp->pcCommandString;
                    psCommand = psCommandTemp->psCommandSubMenu;
                }
                else if(psCommandTemp->pfCommandInterpreter != NULL) {
        		    pcCommondParamExtract = (char *)&pcCommandInput[xCommandStringLength];//Parameter after the command string.
                    psCommandTemp->pfCommandInterpreter();//callback
                }

				break;
			}
		}
	}

	if(psCommandTemp->pcCommandString == NULL) {

		/* The command was found, but the number of parameters with the command was incorrect. */
		debugPrintInfo(CLI_isDebugOn, " \r\n\r\n Enter 'ls .' to view a list of available commands.\r\n Note the case distinction.\r\n");
	}
}

/**
  * @brief  : Convert string to growth integer.
  * @param  : None
  * @retval : return signed int
  */
static int32_t getLongValue(void)
{
    int32_t value = 0;
    char *ptr = pcCommondParamExtract;

    if((ptr == NULL) || (*ptr == '\0')) return 0;
    value = strtol(pcCommondParamExtract, &pcCommondParamExtract, 10);

    return value;
}

/**
  * @brief  : Converts a string to an unsigned long integer number.
  * @param  : None
  * @retval : return unsigned int
  */
static uint32_t getULongValue(void)
{
    uint32_t value = 0;
    char *ptr = pcCommondParamExtract;

    if((ptr == NULL) || (*ptr == '\0')) return 0;
    value = strtoul(pcCommondParamExtract, &pcCommondParamExtract, 10);

    return value;
}

/**
  * @brief  : Command line tool usage instructions
  * @param  : None
  * @retval : None
  */
static void help(void)
{
    debugPrintInfo(CLI_isDebugOn, "\r\n\r\n");
    debugPrintInfo(CLI_isDebugOn, "===============================================================\r\n");
    debugPrintInfo(CLI_isDebugOn, "             Command line tool usage instructions              \r\n");
    debugPrintInfo(CLI_isDebugOn, "***************************************************************\r\n");
    debugPrintInfo(CLI_isDebugOn, "Format: 'command param1 ...': Command function description.    \r\n");
    debugPrintInfo(CLI_isDebugOn, "        Commands and parameters are separated by Spaces.       \r\n");
    debugPrintInfo(CLI_isDebugOn, "        Multiple parameter are separated by Spaces.            \r\n");
    debugPrintInfo(CLI_isDebugOn, "        Parameter can be null: 'command'.                      \r\n");
    debugPrintInfo(CLI_isDebugOn, "        Command input completed, press enter key to execute.   \r\n");
    debugPrintInfo(CLI_isDebugOn, "        You can enter 'ls .' to view each command format.      \r\n");
    debugPrintInfo(CLI_isDebugOn, "Notice: If you are in a submenu, use the 'cd /' to return.     \r\n");
    debugPrintInfo(CLI_isDebugOn, "***************************************************************\r\n");
    debugPrintInfo(CLI_isDebugOn, "===============================================================\r\n");
}

/**
  * @brief  : Display system version information.
  * @param  : None
  * @retval : None
  */
static void infoSysVersion(void)
{
    debugPrintInfo(CLI_isDebugOn, "\r\n\r\n");
    debugPrintInfo(CLI_isDebugOn, "===============================================================\r\n");
    debugPrintInfo(CLI_isDebugOn, "                  Command Line Tool Interface                  \r\n");
    debugPrintInfo(CLI_isDebugOn, "                JUNGLEEEE CopyRight 2018 - 2018                \r\n");
    debugPrintInfo(CLI_isDebugOn, "***************************************************************\r\n");
#ifdef DEBUG
    debugPrintInfo(CLI_isDebugOn, "* FIRMWARE VERSION: V24.18.%02d.%02d Debug\r\n",   VersionMajor, VersionMinor);
#else
    debugPrintInfo(CLI_isDebugOn, "* FIRMWARE VERSION: V24.18.%02d.%02d Release\r\n", VersionMajor, VersionMinor);
#endif
    debugPrintInfo(CLI_isDebugOn, "* build-essential : KEIL MDK V%d.\r\n",__ARMCC_VERSION);
    debugPrintInfo(CLI_isDebugOn, "* compile date    : %s, %s.\r\n",    __DATE__,__TIME__);
    debugPrintInfo(CLI_isDebugOn, "***************************************************************\r\n");
    debugPrintInfo(CLI_isDebugOn, "===============================================================\r\n");
}

/**
  * @brief  : List all the register commond
  * @param  : None
  * @retval : None
  */
static void listShowAllCommond(void)
{
    const CLI_Command_Definition_t *psCommandTemp = (CLI_Command_Definition_t *)psCommand;

    debugPrintInfo(CLI_isDebugOn, "\r\n");
    for(; psCommandTemp->pcCommandString != NULL; psCommandTemp++) {

		/* Print a list of all the commands. */
        debugPrintInfo(CLI_isDebugOn, "%s", psCommandTemp->pcHelpString);
    }
    debugPrintInfo(CLI_isDebugOn, "\r\n");
}

/**
  * @brief  : Lists all task priority&stack status
  * @param  : None
  * @retval : None
  */
static void taskStackStatsShow(void)
{
    static const char * const pcHeader = "\r\n\r\nTaskName        Used/Free       usage       \r\n*****************************************\r\n";

    OS_ERR err;
    CPU_STK_SIZE free, used;

    debugPrintInfo(CLI_isDebugOn, pcHeader);

    OSTaskStkChk((OS_TCB *)&startTaskTCB, &free, &used, &err);
    debugPrintInfo(CLI_isDebugOn, "startTask          %d/%d            %d   \r\n", used, free, (used * 100)/(used + free));

    OSTaskStkChk((OS_TCB *)&cliSendTaskTCB, &free, &used, &err);
    debugPrintInfo(CLI_isDebugOn, "cliSendTask        %d/%d            %d   \r\n", used, free, (used * 100)/(used + free));

    OSTaskStkChk((OS_TCB *)&cliReceiveTaskTCB, &free, &used, &err);
    debugPrintInfo(CLI_isDebugOn, "cliReceiveTask     %d/%d            %d   \r\n", used, free, (used * 100)/(used + free));
}

/**
  * @brief  : View the remaining idle heap size of the system.
  * @param  : None
  * @retval : None
  */
static void systemStackStatsShow(void)
{

}

/**
  * @brief  : Open or close the module debugging information printing.
  * @param  : None
  * @retval : None
  */
static void debugPrintOnOff(void)
{
    static const char * const pcHeader = "\r\n\r\n* Current All Module Debugging Switch Status: \r\n**********************************************\r\n";
    static const char *debugName[DEBUG_PRINT_INDEX_NUM + 1] = {"* 1. Command line Debug",
                                                               "* 2.       System Debug",
                                                               "* 3.  Communicate Debug",
                                                               "* 4.     Position Debug",
                                                               "* 99.  All Debug-module",};
    uint32_t index = (uint32_t)getULongValue();
    uint8_t oper = (uint8_t)getLongValue();

    if(index == 0) {

        debugPrintInfo(CLI_isDebugOn, pcHeader);
        for(int i = CLI_DEBUG_PRINT;i < DEBUG_PRINT_INDEX_NUM;i++) {
            //display all
            debugPrintInfo(CLI_isDebugOn, "%s : %s\r\n", debugName[i], (((xCliDebugStatus.cliDebugStatus >> i) & 0x01) ? "ON" : "OFF"));
        }

        debugPrintInfo(CLI_isDebugOn, "%s\r\n", debugName[DEBUG_PRINT_INDEX_NUM]);
        debugPrintInfo(CLI_isDebugOn, "**********************************************\r\n");
    }
    else if(index == 99) {

        if(!oper) {//all close
            xCliDebugStatus.cliDebugStatus = cli_DEBUG_DEFAULT_STATUS;
        }
        else xCliDebugStatus.cliDebugStatus = 0xffffffff;

        debugPrintInfo(CLI_isDebugOn, "\r\n\r\n* Please re-enter 'debug' or 'debug 0' to view the latest status.\r\n");
    }
    else {

        if(index > DEBUG_PRINT_INDEX_NUM) {
            debugPrintInfo(CLI_isDebugOn, "\r\n\r\n* Input parameter error, please verify.\r\n");return;
        }

        index--;
        if((index == CLI_DEBUG_PRINT) || (index == SYS_DEBUG_PRINT)) {
            debugPrintInfo(CLI_isDebugOn, "\r\n\r\n%s : Not allowed to be manipulated.\r\n", debugName[index]);
        }
        else {

            if(!oper) {//close index
                xCliDebugStatus.cliDebugStatus  &= (unsigned int)(~(1u << index));
            }
            else xCliDebugStatus.cliDebugStatus |= ((unsigned int)(1u << index));

            debugPrintInfo(CLI_isDebugOn, "\r\n\r\n%s : %s\r\n", debugName[index], (((xCliDebugStatus.cliDebugStatus >> (index)) & 0x01) ? "ON" : "OFF"));
        }
    }
}

static const CLI_Command_Definition_t xSysCommandSubMenu[] =
{
	{"task",  "\r\n\ttask : Lists all task priority&stack status.",           (const CLI_Command_Definition_t *)NULL, (pfCOMMAND_LINE_CALLBACK)taskStackStatsShow},
	{"stack", "\r\n\tstack: View the remaining idle heap size of the system.",(const CLI_Command_Definition_t *)NULL, (pfCOMMAND_LINE_CALLBACK)systemStackStatsShow},
	{"debug", "\r\n\tdebug: Open or close the module debugging information printing.\r\n\t       Input 'debug' or 'debug 0' to view the latest status.\r\n\t       Input 'debug Num 0' to close or 'debug Num 1' to open.",
	                                                                          (const CLI_Command_Definition_t *)NULL, (pfCOMMAND_LINE_CALLBACK)debugPrintOnOff},
    CLI_Command_Definition_t_End
};

static const CLI_Command_Definition_t xTestCommandSubMenu[] =
{
	{"test",  "\r\n\ttest : test, this is NULL.", (const CLI_Command_Definition_t *)NULL, (pfCOMMAND_LINE_CALLBACK)NULL},
    CLI_Command_Definition_t_End
};

/**
  * @}
  */

/************************** Coopyright (C) Jungleeee 2018 *******END OF FILE*******/

