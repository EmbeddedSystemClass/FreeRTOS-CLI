/**
  ********************************************************************************
  * @File Name    : cli_register.c
  * @Author       : Jungle
  * @Mail         : Mail
  * @Created Time : 2018Äê3ÔÂ20ÈÕ 10:21:43
  * @Version      : V1.0
  * @Last Changed : 2018/4/11 10:52:07
  * @Brief        : brief
  ********************************************************************************
  */

/* Inlcude ---------------------------------------------------------------------*/
#include "FreeRTOS.h"
#include "queue.h"
#include "task.h"

#include "stdio.h"
#include "stdlib.h"
#include "string.h"

#include <cli_common.h>
#include <cli_register.h>

/** @addtogroup Cli_Project
  * @{
  */

/* Private typedef -------------------------------------------------------------*/
typedef void (* pfCOMMAND_LINE_CALLBACK)(void);
typedef struct sCOMMAND_LINE_INPUT
{
	const char * const pcCommandString;/* The command that causes pfCommandInterpreter to be executed. For example "help".  Must be all lower case. */
	const char * const pcHelpString;   /* String that describes how to use the command. Should start with the command itself, and end with "\r\n".
	                                      For example "help: Display command line tool usage instructions\r\n". */
    const struct sCOMMAND_LINE_INPUT * psCommandSubMenu;/* If this command is a Submenu */
	const pfCOMMAND_LINE_CALLBACK pfCommandInterpreter;	/* A pointer to the callback function that will return the output generated by the command. */
}CLI_Command_Definition_t;

/* Private constants define ----------------------------------------------------*/
/* Private macro define --------------------------------------------------------*/
#define CLI_COMMOND_DEFINITION_T_END        {NULL, NULL, (const CLI_Command_Definition_t *)NULL, (pfCOMMAND_LINE_CALLBACK)NULL}
#define CLI_IS_ON_DEBUG                     xCliDebugStatus.Bits.CLI

/* Private function declaration ------------------------------------------------*/
static void help(void);
static void list_show_all_commond(void);
static void info_system_version(void);

/* Private variables -----------------------------------------------------------*/
static char * pcCommondParamExtract = NULL;
static const CLI_Command_Definition_t xSysCommandSubMenu[];
static const CLI_Command_Definition_t xTestCommandSubMenu[];

/* The definition of the "help" command.  This command is always at the front of the list of registered commands. */
/* The definition of the list of commands.  Commands that are registered are added to this list. */
static const CLI_Command_Definition_t xRegisteredCommands[] =
{
	{"info", "\r\n\tinfo: Display system version information.",   (const CLI_Command_Definition_t *)NULL, (pfCOMMAND_LINE_CALLBACK)info_system_version},
	{"SYS",  "\r\n\tSYS : Enter the system debug submenu.",       xSysCommandSubMenu,                     (pfCOMMAND_LINE_CALLBACK)NULL},
	{"TEST", "\r\n\tTEST: Enter the system test submenu.",        xTestCommandSubMenu,                    (pfCOMMAND_LINE_CALLBACK)NULL},
	CLI_COMMOND_DEFINITION_T_END
};
static const CLI_Command_Definition_t *psCommand = xRegisteredCommands;

/* Firmware version definition */
static const unsigned char VersionMajor = 01;
static const unsigned char VersionMinor = 01;

extern const char * pcMenuNameString;

/* Private functions -----------------------------------------------------------*/
/**
  * @brief  : vApplicationStackOverflowHook.
  * @param  : None
  * @retval :
  */
void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName )
{
    printf("!!!!!! %s StackOverflow !!!!!!", pcTaskName);
}

/**
  * @brief  :
  * @param  : None
  * @retval : None
  */
void cli_interpret_command(const char * const pcCommandInput)
{
    static const char * const CLI_Commond_Return_Main_Menu = "cd /";//4
    static const char * const CLI_Commond_List_All_Commond = "ls .";//4
    static const char * const CLI_Commond_Help_Info = "help";//4

    const CLI_Command_Definition_t *psCommandTemp = psCommand;

    const char *pcRegisteredCommandString;
    unsigned char xCommandStringLength;

    if(strncmp(pcCommandInput, CLI_Commond_Return_Main_Menu, 4) == 0) {
        psCommand = xRegisteredCommands;//root
        pcMenuNameString = pcCmdLineString;
        return;
    }

    if(strncmp(pcCommandInput, CLI_Commond_List_All_Commond, 4) == 0) {
        list_show_all_commond();
        return;
    }

    if(strncmp(pcCommandInput, CLI_Commond_Help_Info, 4) == 0) {
        help();
        return;
    }

    /* Search for the command string in the list of registered commands. */
	for(; psCommandTemp->pcCommandString != NULL; psCommandTemp++) {

		pcRegisteredCommandString = psCommandTemp->pcCommandString;
		xCommandStringLength = strlen(pcRegisteredCommandString);

		/* To ensure the string lengths match exactly, so as not to pick up a sub-string of a longer command,
		check the byte after the expected end of the string is either the end of the string or a space before a parameter. */
		if((pcCommandInput[xCommandStringLength] == ' ') || (pcCommandInput[xCommandStringLength] == 0x00)) {

			if(strncmp(pcCommandInput, pcRegisteredCommandString, xCommandStringLength) == 0) {//strncmp: Match Case

				/* The command has been found.  Check it has the expected number of parameters.
				If cExpectedNumberOfParameters is -1, then there could be a variable number of parameters and no check is made. */
				if(psCommandTemp->psCommandSubMenu != NULL) {
                    pcMenuNameString = psCommandTemp->pcCommandString;
                    psCommand = psCommandTemp->psCommandSubMenu;
                }
                else if(psCommandTemp->pfCommandInterpreter != NULL) {
        		    pcCommondParamExtract = (char *)&pcCommandInput[xCommandStringLength];//Parameter after the command string.
                    psCommandTemp->pfCommandInterpreter();//callback
                }

				break;
			}
		}
	}

	if(psCommandTemp->pcCommandString == NULL) {

		/* The command was found, but the number of parameters with the command was incorrect. */
		DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, " \r\n\r\n Enter 'ls .' to view a list of available commands.\r\n Note the case distinction.\r\n");
	}
}

/**
  * @brief  : Convert string to growth integer.
  * @param  : None
  * @retval : return signed int
  */
static int32_t get_long_value(void)
{
    int32_t value = 0;
    char *ptr = pcCommondParamExtract;

    if((ptr == NULL) || (*ptr == '\0')) return 0;
    value = strtol(pcCommondParamExtract, &pcCommondParamExtract, 10);

    return value;
}

/**
  * @brief  : Converts a string to an unsigned long integer number.
  * @param  : None
  * @retval : return unsigned int
  */
static uint32_t get_ulong_value(void)
{
    uint32_t value = 0;
    char *ptr = pcCommondParamExtract;

    if((ptr == NULL) || (*ptr == '\0')) return 0;
    value = strtoul(pcCommondParamExtract, &pcCommondParamExtract, 10);

    return value;
}

/**
  * @brief  : Command line tool usage instructions
  * @param  : None
  * @retval : None
  */
static void help(void)
{
    portENTER_CRITICAL();
    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "\r\n\r\n");
    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "===============================================================\r\n");
    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "             Command line tool usage instructions              \r\n");
    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "***************************************************************\r\n");
    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "Format: 'command param1 ...': Command function description.    \r\n");
    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "        Commands and parameters are separated by Spaces.       \r\n");
    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "        Multiple parameter are separated by Spaces.            \r\n");
    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "        Parameter can be null: 'command'.                      \r\n");
    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "        Command input completed, press enter key to execute.   \r\n");
    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "        You can enter 'ls .' to view each command format.      \r\n");
    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "Notice: If you are in a submenu, use the 'cd /' to return.     \r\n");
    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "***************************************************************\r\n");
    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "===============================================================\r\n");
    portEXIT_CRITICAL();
}

/**
  * @brief  : Display system version information.
  * @param  : None
  * @retval : None
  */
static void info_system_version(void)
{
    portENTER_CRITICAL();
    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "\r\n\r\n");
    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "===============================================================\r\n");
    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "                  Command Line Tool Interface                  \r\n");
    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "                JUNGLEEEE CopyRight 2018 - 2018                \r\n");
    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "***************************************************************\r\n");
#ifdef DEBUG
    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "* FIRMWARE VERSION: V24.18.%02d.%02d Debug\r\n",   VersionMajor, VersionMinor);
#else
    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "* FIRMWARE VERSION: V24.18.%02d.%02d Release\r\n", VersionMajor, VersionMinor);
#endif
    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "* build-essential : KEIL MDK V%d.\r\n",__ARMCC_VERSION);
    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "* compile date    : %s, %s.\r\n", __DATE__,__TIME__);
    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "***************************************************************\r\n");
    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "===============================================================\r\n");
    portEXIT_CRITICAL();
}

/**
  * @brief  : List all the register commond
  * @param  : None
  * @retval : None
  */
static void list_show_all_commond(void)
{
    const CLI_Command_Definition_t *psCommandTemp = (CLI_Command_Definition_t *)psCommand;

    portENTER_CRITICAL();
    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "\r\n");
    for(; psCommandTemp->pcCommandString != NULL; psCommandTemp++) {

		/* Print a list of all the commands. */
        DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "%s", psCommandTemp->pcHelpString);
    }
    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "\r\n");
    portEXIT_CRITICAL();
}

/**
  * @brief  : Lists all task priority&stack status
  * @param  : None
  * @retval : None
  */
static void taskStackStatsShow(void)
{
    static const char * const pcStackHeader = "\r\n\r\nTaskName        S       P       Stack   #ID\r\n**********************************************\r\n";
    /* Application for memory storage system task information.
       According to the actual test, *** each task information needs about 20 character Spaces ***.
       char pcWriteBuffer[2][CLI_MAX_TX_QUEUE_LEN] = {0}: More than 40 system task information can be saved.
       This format is defined because the print output allows up to 200(CLI_MAX_TX_QUEUE_LEN) bytes at a time, and is convenient for subsequent operations.
    */
    static char pcWriteBuffer[2][CLI_MAX_TX_QUEUE_LEN] = {0};

    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, pcStackHeader);

    /* Set #define configUSE_TRACE_FACILITY		1  &&  #define configUSE_STATS_FORMATTING_FUNCTIONS    1 */
    vTaskList((char *)pcWriteBuffer);

    /* Print output is allowed at most 200(CLI_MAX_TX_QUEUE_LEN) bytes each time.
       "%-200.200s"¡úplease refer to the website https://www.cnblogs.com/ai616818/archive/2012/05/31/2528472.html
    */
    portENTER_CRITICAL();
    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "%-200.200s", (char *)&pcWriteBuffer[0]);
    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "%-200.200s", (char *)&pcWriteBuffer[1]);
    portEXIT_CRITICAL();
}

/**
  * @brief  : View the remaining idle heap size of the system.
  * @param  : None
  * @retval : None
  */
static void systemStackStatsShow(void)
{
    size_t xCurrentFreeHeapSize = xPortGetFreeHeapSize();
    size_t xMinimumEverFreeHeapSize= xPortGetMinimumEverFreeHeapSize();

    portENTER_CRITICAL();
    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "\r\n\r\n* Current remaining idle heap size : %d.\r\n", xCurrentFreeHeapSize);
    DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "* The remaining minimum idle heap size in the running process : %d.\r\n", xMinimumEverFreeHeapSize);
    portEXIT_CRITICAL();
}

/**
  * @brief  : Open or close the module debugging information printing.
  * @param  : None
  * @retval : None
  */
static void debugPrintOnOff(void)
{
    static const char * const pcDebugHeader = "\r\n\r\n* Current All Module Debugging Switch Status: \r\n**********************************************\r\n";
    static const char *debugName[DEBUG_PRINT_INDEX_NUM + 1] = {"* 1. Command line Debug",
                                                               "* 2.       System Debug",
                                                               "* 3.  Communicate Debug",
                                                               "* 4.     Position Debug",
                                                               "* 5.      Network Debug",
                                                               "* 99.  All Debug-module",};
    uint32_t index = (uint32_t)get_ulong_value();
    uint8_t oper = (uint8_t)get_long_value();

    if(index == 0) {

        DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, pcDebugHeader);
        for(int i = CLI_DEBUG_PRINT;i < DEBUG_PRINT_INDEX_NUM;i++) {
            //display all
            DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "%s : %s\r\n", debugName[i], (((xCliDebugStatus.cliDebugStatus >> i) & 0x01) ? "ON" : "OFF"));
        }

        DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "%s\r\n", debugName[DEBUG_PRINT_INDEX_NUM]);
        DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "**********************************************\r\n");
    }
    else if(index == 99) {

        if(!oper) {//all close
            xCliDebugStatus.cliDebugStatus = CLI_DEBUG_DEFAULT_STATUS;
        }
        else xCliDebugStatus.cliDebugStatus = 0xffffffff;

        DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "\r\n\r\n* Please re-enter 'debug' or 'debug 0' to view the latest status.\r\n");
    }
    else {

        if(index > DEBUG_PRINT_INDEX_NUM) {
            DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "\r\n\r\n* Input parameter error, please verify.\r\n");return;
        }

        index--;
        if((index == CLI_DEBUG_PRINT) || (index == SYS_DEBUG_PRINT)) {
            DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "\r\n\r\n%s : Not allowed to be manipulated.\r\n", debugName[index]);
        }
        else {

            if(!oper) {//close index
                xCliDebugStatus.cliDebugStatus  &= (unsigned int)(~(1u << index));
            }
            else xCliDebugStatus.cliDebugStatus |= ((unsigned int)(1u << index));

            DEBUG_PRINT_INFO(CLI_IS_ON_DEBUG, "\r\n\r\n%s : %s\r\n", debugName[index], (((xCliDebugStatus.cliDebugStatus >> (index)) & 0x01) ? "ON" : "OFF"));
        }
    }
}

static const CLI_Command_Definition_t xSysCommandSubMenu[] =
{
	{"task",  "\r\n\ttask : Lists all task priority&stack status.",           (const CLI_Command_Definition_t *)NULL, (pfCOMMAND_LINE_CALLBACK)taskStackStatsShow},
	{"stack", "\r\n\tstack: View the remaining idle heap size of the system.",(const CLI_Command_Definition_t *)NULL, (pfCOMMAND_LINE_CALLBACK)systemStackStatsShow},
	{"debug", "\r\n\tdebug: Open or close the module debugging information printing.\r\n\t       Input 'debug' or 'debug 0' to view the latest status.\r\n\t       Input 'debug Num 0' to close or 'debug Num 1' to open.",
	                                                                          (const CLI_Command_Definition_t *)NULL, (pfCOMMAND_LINE_CALLBACK)debugPrintOnOff},
    CLI_COMMOND_DEFINITION_T_END
};

static const CLI_Command_Definition_t xTestCommandSubMenu[] =
{
	{"test",  "\r\n\ttest : test, this is NULL.", (const CLI_Command_Definition_t *)NULL, (pfCOMMAND_LINE_CALLBACK)NULL},
    CLI_COMMOND_DEFINITION_T_END
};

/**
  * @}
  */

/************************** Coopyright (C) Jungleeee 2018 *******END OF FILE*******/

